

ref:

https://www.chaindesk.cn/witbook/13/184



# 1.函数 数据类型

1. Golang中的函数可以作为一种复合的数据类型

2. 函数：作为一种复合的数据类型，**看作是一种特殊的变量**。
       函数名（）-->将函数进行调用，函数中的代码全部都会执行，然后将执行结果(return后的数据)返回。

   ​    函数名-->理解为指向函数体的**内存地址**，即函数指针。

3. 例子

   ```go
   package main
   
   import "fmt"
   
   func main() {
       /*
       Go语言的数据类型：
           数值类型：整数，浮点
               会进行运算操作：加减乘除
   
           字符串：可以获取单个自负，截取子串，遍历，strings包下的函数。。。
   
           数组，切片，map。。
               容器类：存储数据，获取数据，遍历数据，更改数据。。。。
   
           函数：
               加(),进行调用
   
       函数：作为一种复合的数据类型，看作是一种特殊的变量。
           函数名()-->将函数进行调用，函数中的代码全部都会执行，然后将执行结果(return后的数据)返回。
   
           函数名-->理解为指向函数体的内存地址。
   
        */
       //3.函数作为一个变量
       fmt.Printf("%T\n", fun1) //func (int,int)
       fmt.Println(fun1)        //0x489ea0,看作函数名对应的函数体的地址。
   
       //4.直接定义一个函数类型的变量
       var c func(int, int)
       fmt.Println(c) //<nil>,空
   
       c = fun1 //将fun1的值(函数体的地址)，赋值给c
       fmt.Println(c)
   
       fun1(10, 20)
       c(100, 200)
   
       res1 := fun2 //将fun2的值(函数的地址),赋值给res1,res1和fun2指向同一个函数体
       res2 := fun2(1, 2)//将fun2函数进行调用，将函数的执行结果，赋值给res2,相当于：res = a+b
       fmt.Println(res2) // 3
       fmt.Println(res1)
   
       fmt.Println(res1(10,20))
   
       //res2() //cannot call non-function res2 (type int)
   
   
   }
   func fun1(a, b int) {
       fmt.Println("a:", a, ",b:", b)
   }
   
   func fun2(a, b int) int {
       return a + b
   }
   ```

   



# 2.匿名函数

1. 匿名函数，就是没有名字的函数。

2. 定义一个匿名函数，直接进行调用。**通常只能使用一次**。也可以将匿名函数赋值给某个函数变量。那么可以调用多次。

3. 匿名函数作用：
    1.将函数作为另一个函数的**参数**。（回调函数）
    2.将函数作为另一个函数的**返回值**。

4. 例子：

   ```go
   package main
   
   import "fmt"
   
   func main() {
        fun1()//调用函数
       fun1()
        fun2:=fun1
        fun2()//调用函数
   
        //匿名函数：
        func (){
            fmt.Println("我是一个匿名函数。。")
        }()
   
        fun3:=func(){
            fmt.Println("我也是一个匿名函数。。")
        }
   
        fun3()
        fun3()
   
        //定义带参数的匿名函数
        func(a, b int){
            fmt.Println(a, b)
        }(1,2)
   
        //定义带返回值的函数
   
        res1:=func(a, b int)int{
            return a + b
        }(10,20) //匿名函数调用了，将调用执行的结果给res1
        fmt.Println(res1)
   
   
        res2 :=func(a,b int)int{
            return a+b
        }//将匿名函数的值，赋值给res2
        fmt.Println(res2)
   
   
   }
   
   func fun1(){
       fmt.Println("我是fun1函数。。")
   }
   ```

# 



# 3.回调函数

1. 高阶函数：
    根据go语言的数据类型的特点，可以将一个函数作为另一个函数的参数。
2.  `fun1(),fun2()`
   将`fun1`函数作为了`fun2`这个函数的参数。
3.  `fun2`函数：就叫高阶函数
    接收了一个函数作为参数的函数，**高阶函数**
    `fun1`函数：回调函数
    作为另一个函数的参数的函数，叫做**回调函数**。





# 4.闭包

1. go语言支持**函数式编程**：
   支持将一个函数作为另一个函数的**参数**，
   也支持将一个函数作为另一个函数的**返回值**。
2. ==闭包：closure==：
   + 一个外层函数中，有内层函数，该内层函数中，会操作**外层函数中的局部变量**(外层函数中的参数，
     或者外层函数直接定义的变量)，并且**该外层函数的返回值就是这个内层函数**。
   + 该**内层函数**和**外层函数的局部变量**，统称为==<u>闭包结构</u>==。
   + 局部变量的生命周期会发生改变，正常的局部变量随着函数的调用而创建，<u>随着函数的结束而销毁</u>。
     但是<u>闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁</u>，因为**内层函数还要继续使用**。