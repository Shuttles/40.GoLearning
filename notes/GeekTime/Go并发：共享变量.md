# Go并发：共享变量



# 1.前言

1. Go 语言之父 Rob Pike 还有一句经典名言：“<u>不要通过共享内存来通信，应该通过通信来共享内存</u>（Don’t communicate by sharing memory, share memory by communicating）”，这就奠定了 Go 应用并发设计的主流风格：**使用 channel 进行不同 Goroutine 间的通信**。
2. 不过，Go 也并没有彻底放弃基于共享内存的并发模型，而是在提供 CSP 并发模型原语的同时，还通过标准库的 sync 包，提供了针对传统的、**基于共享内存并发模型的低级同步原语**，包括：**互斥锁**（**sync.Mutex**）、**读写锁**（sync.**RWMutex**）、**条件变量**（**sync.Cond**）等，并通过 atomic 包提供了原子操作原语等等。显然，基于共享内存的并发模型在 Go 语言中依然有它的“用武之地”。



# 2.sync包低级同步原语

一般情况下，我建议你优先使用 CSP 并发模型进行并发程序设计。但是在下面一些场景中，我们依然需要 sync 包提供的低级同步原语



## 2.1需要高性能的临界区（critical section）同步机制场景

1. 在 Go 中，channel 并发原语也可以用于对数据对象访问的同步，我们可以把 channel 看成是一种高级的同步原语，它自身的实现也是建构在**低级同步原语**之上的。也正因为如此，<u>channel 自身的性能与低级同步原语相比要略微逊色，开销要更大</u>。

2. 这里，关于 sync.Mutex 和 channel 各自实现的临界区同步机制，我做了一个简单的性能基准测试对比，通过对比结果，我们可以很容易看出两者的性能差异：

   ```go
   
   var cs = 0 // 模拟临界区要保护的数据
   var mu sync.Mutex
   var c = make(chan struct{}, 1)
   
   func criticalSectionSyncByMutex() {
       mu.Lock()
       cs++
       mu.Unlock()
   }
   
   func criticalSectionSyncByChan() {
       c <- struct{}{}
       cs++
       <-c
   }
   ```

3. 我们可以看到，无论是在单 Goroutine 情况下，还是在并发测试情况下，<u>sync.Mutex实现的同步机制的性能，都要比 channel 实现的高出三倍多</u>。因此，通常在需要高性能的临界区（critical section）同步机制的情况下，sync 包提供的低级同步原语更为适合。



## 2.2不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景

1. 基于 channel 的并发设计，有一个特点：在 Goroutine 间通过 channel 转移数据对象的所有权。所以，只有拥有数据对象所有权（从 channel 接收到该数据）的 Goroutine 才可以对该数据对象进行状态变更。
2. 如果你的设计中没有转移结构体对象所有权，但又要保证结构体内部状态数据在多个 Goroutine 之间同步访问，那么你可以使用 sync 包提供的低级同步原语来实现，比如最常用的sync.Mutex。



## 2.3注意事项





## 2.4Mutex



## 2.5RWMutex



## 2.6Cond





# 3.原子操作（atomic）







# 总结

1. 虽然 Go 推荐**基于通信来共享内存**的并发设计风格，但 Go 并没有彻底抛弃对基于共享内存并发模型的支持，
2. Go 通过标准库的 sync 包以及 atomic 包提供了**低级同步原语**。这些原语有着它们自己的应用场景。
3. 如果我们考虑使用低级同步原语，一般都是因为低级同步原语可以提供更佳的性能表现，性能基准测试结果告诉我们，<u>使用低级同步原语的性能可以高出 channel 许多倍</u>。在性能敏感的场景下，我们依然离不开这些低级同步原语。
4. 在使用 sync 包提供的同步原语之前，我们一定要牢记这些原语使用的注意事项：**不要复制<u>首次使用</u>后的 Mutex/RWMutex/Cond 等**。一旦复制，你将很大可能得到意料之外的运行结果。
5. sync 包中的低级同步原语各有各的擅长领域，你可以记住
   + 在<u>具有一定并发量且读多写少</u>的场合使用 **RWMutex**
   + 在需要“<u>等待某个条件成立</u>”的场景下使用 **Cond**；
   + 当你<u>不确定</u>使用什么原语时，那就使用 **Mutex** 吧
6. 如果你对同步的性能有<u>极致要求，且并发量较大，读多写少</u>，那么可以考虑一下 atomic 包提供的原子操作函数。