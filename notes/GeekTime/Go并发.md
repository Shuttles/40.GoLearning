# Go并发

原文：https://time.geekbang.org/column/article/475959

# 1.前言

1. 设计者果断将面向多核，原生支持并发作为设计目标之一



# 2.并发与并行

c cpp以操作系统线程作为承载分解后的代码模块的执行单元，由OS执行调度。这种传统支持并发的方式有很多不足：

1. 复杂
   + 创建容易退出难
   + 线程通信复杂
2. 难以规模化
   + OS调度切换线程的代价也不小



# 3.Goroutine

1. Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了==goroutine==这一由 Go 运行时（runtime）负责调度的、轻量的用户级线程，为并发程序设计提供原生支持。
2. 其优势在于
   + **资源占用小**，每个 goroutine 的初始栈大小仅为 2k；
   + 由 **Go 运行时而不是操作系统调度**，goroutine 上下文切换在用户层完成，开销更小；
   + **在语言层面而不是通过标准库提供**。goroutine 由go关键字创建，一退出就会被回收或销毁，开发体验更佳；
   + 语言内置 ==channel== 作为 **goroutine 间通信原语**，为并发设计提供了强大支撑。
3. Go是面向并发而生的，所以Go的惯例是优先考虑并发设计，通过并发设计的Go应用可以更好的，更自然的适应规模化。



## 3.2Goroutine间的通信

1. 传统语言的并发通信是基于**对内存的共享的**，**难用且易错**

2. Go的并发模型借鉴了著名计算机科学家Tony Hoare提出的CSP（Communicating Sequential Processes，==通信顺序进程==）并发模型，其旨在让并发程序的编写与编写顺序程序一样简单。

3. 在 Tony Hoare 眼中，一个符合 CSP 模型的并发程序应该是<u>一组通过输入输出原语连接起来的 P 的集合</u>。

   Tony Hoare 的 CSP 理论中的 P，也就是“Process（进程）”，是一个抽象概念，它代表任何顺序处理逻辑的封装，它获取输入数据（或从其他 P 的输出获取），并生产出可以被其他 P 消费的输出数据。

4. 为了实现 CSP 并发模型中的输入和输出原语，Go 还引入了 goroutine（P）之间的**通信原语channel**。<u>goroutine 可以从 channel 获取输入数据，再将处理后得到的结果数据通过 channel 输出。</u>

5. 通过 channel 将 goroutine（P）组合连接在一起，让设计和编写大型并发系统变得更加简单和清晰，我们再也不用为那些传统共享内存并发模型中的问题而伤脑筋了。

6. 问题：如何获取goroutine的==退出==状态？（答案在原文中）



1. 虽然 CSP 模型已经成为 Go 语言支持的主流并发模型，但 Go 也支持传统的、基于共享内存的并发模型，并提供了基本的低级别同步原语（主要是 sync 包中的互斥锁、条件变量、读写锁、原子操作等）。
2. 对于局部情况，比如==涉及性能敏感的区域==或==需要保护的结构体数据==时，我们可以使用更为高效的低级同步原语（如 mutex），保证 goroutine 对数据的同步访问。



# 总结

1. 并发不是并行，并发是**应用结构设计相关**的概念，而并行只是**程序执行期**的概念。

   并行的必要条件是具有多个cpu或多核cpu，否则无论是否是并发的设计，程序执行时都有且仅有一个任务可以被调度到cpu上执行

2. 传统语言如c cpp的并发程序设计方案是**基于OS的线程调度模型的**，这种模型与OS的调度强耦合，且对于开发人员来说十分**复杂**，体验较差且**易错**。

3. 而Go给出的并发方案是**基于轻量级线程goroutine的**。goroutine**占用的资源非常小**，创建，切换以及销毁的开销很小。

   并且Go在语法层面原生支持基于goroutine的并发，通过一个Go关键字就可以轻松创建goroutine，开发者**体验极佳**