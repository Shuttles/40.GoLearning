# 接口1:接口即契约

原文链接

https://time.geekbang.org/column/article/471952



# 1.基础语法

## 1.1基础

1. 接口类型是由 **type** 和 **interface** 关键字定义的**一组方法集合**，其中，<u>方法集合唯一确定了这个接口类型所表示的接口</u>。下面是一个典型的接口类型 MyInterface 的定义：

   ```go
   type MyInterface interface {
     M1(int) error
     M2(io.Write, ...string)
   }
   ```

2. 从上面接口类型声明中各个“方法”的**形式**上来看，这更像是<u>不带有 func 关键字的函数名 + 函数签名（参数列表 + 返回值列表）的组合。</u>

3. 我们在接口类型的方法集合中声明的方法，它的参数列表**不需要**写出**形参名字，返回值列表**也是如此。

   也就是说，==方法的参数列表中形参名字与返回值列表中的具名返回值，都不作为区分两个方法的凭据==。

4. 不过，Go 语言要求接口类型声明中的**方法必须是具名**的，并且方法名字在这个接口类型的方法集合中是**唯一**的

5. Go 1.14 版本以后，Go 接口类型**允许嵌入的不同接口类型的方法集合存在交集**，但前提是<u>交集中的方法不仅名字要一样，它的方法签名部分也要保持一致</u>，也就是参数列表与返回值列表也要相同，否则 Go 编译器照样会报错。

6. 在 Go 接口类型的方法集合中放入首字母小写的非导出方法也是合法的，如果接口类型的方法集合中包含非导出方法，<u>那么这个接口类型自身通常也是非导出的，它的应用范围也仅局限于包内</u>。





## 1.2空接口

1. 如果一个接口类型定义中没有一个方法，那么它的方法集合就为空，比如下面的 EmptyInterface 接口类型：

   ```go
   type EmptyInterface {
     
   }
   ```

2. 这个方法集合为空的接口类型就被称为空接口类型，但通常我们不需要自己显式定义这类空接口类型，我们直接使用==`interface{}`==这个类型字面值作为所有空接口类型的代表就可以了。





## 1.3接口类型变量

1. 接口类型一旦被定义后，它就和其他 Go 类型一样可以用于声明变量，比如：

   ```go
   var err error   // err是一个error接口类型的实例变量
   var r io.Reader // r是一个io.Reader接口类型的实例变量
   ```

2. 这些类型为接口类型的变量被称为**接口类型变量**，如果没有被显式赋予初值，接口类型变量的默认值为 **nil**。如果要为接口类型变量显式赋予初值，我们就要为接口类型变量选择**合法的右值**。

3. Go 规定：==如果一个类型 T 的方法集合是某接口类型 I 的方法集合的等价集合或超集==，我们就说**类型 T 实现了接口类型 I**，那么类型 T 的变量就可以作为合法的右值赋值给接口类型 I 的变量。

4. 如果一个变量的类型是空接口类型，由于空接口类型的方法集合为空，这就意味着<u>任何类型都实现了空接口的方法集合</u>，所以我们可以将任何类型的值作为右值，赋值给空接口类型的变量.

5. 空接口类型的这一可接受任意类型变量值作为右值的特性，让他成为 Go 加入泛型语法之前唯一一种具有“==泛型==”能力的语法元素，



## 1.4类型断言



# 2.尽量定义小接口

## 2.1体现

接口类型的背后，是通过把类型的行为抽象成==契约==，<u>建立双方共同遵守的约定，这种契约将双方的耦合降到了最低的程度</u>。和生活工作中的契约有繁有简，签署方式多样一样，代码间的契约也有多有少，有大有小，而且达成契约的方式也有所不同。 而 Go 选择了去繁就简的形式，这主要体现在以下两点上：

1. **隐式契约，无需签署，自动生效**

   Go 语言中接口类型与它的实现者之间的关系是**隐式**的，不需要像其他语言（比如 Java）那样要求实现者显式放置“implements”进行修饰，实现者只需要实现接口方法集合中的全部方法便算是遵守了契约，并立即生效了。

2. **更倾向于“小契约”**

   这点也不难理解。你想，如果契约太繁杂了就会束缚了手脚，缺少了**灵活性**，抑制了表现力。所以 Go 选择了使用“小契约”，表现在代码上就是尽量定义小接口，即方法个数在 1~3 个之间的接口。Go 语言之父 Rob Pike 曾说过的“<u>接口越大，抽象程度越弱</u>”，这也是 Go 社区倾向定义小接口的另外一种表述。



## 2.2小接口的优势

1. **接口越小，抽象程度越高，对应的事物集合越大。**

2. 小接口表示的“契约”职责单一，**易于复用组合**

   Go 推崇通过<u>组合</u>的方式构建程序。Go 开发人员一般会尝试通过<u>嵌入其他已有接口类型的方式来构建新接口类型</u>，就像通过嵌入 io.Reader 和 io.Writer 构建 io.ReadWriter 那样。

3. **小接口易于实现和测试**

   

   

## 2.3如何定义小接口

1. **首先，别管接口大小，先抽象出接口。**

   专注于接口是编写强大而灵活的 Go 代码的关键

2. 其次，**将大接口拆分为小接口。**

3. 最后，我们要注意接口的**单一契约职责**。

   上面已经被拆分成的小接口是否需要进一步拆分，直至每个接口都只有一个方法呢？





# 总结

1. 系统学习了接口类型的基础知识，包括接口类型的声明、接口类型变量的定义与初始化以及类型断言等，这里面有很多语法细节，一定要牢牢掌握，避免后续在使用接口时走弯路。

   + 某接口类型定义中嵌入的不同接口类型的方法集合若存在交集，**交集中的方法不仅名字要一样，函数签名也要相同**。
   + <u>对接口类型和非接口类型进行类型断言的语义是不完全相同的</u>。

2. Go 接口背后的本质是一种“==契约==”，通过契约我们可以<u>将代码双方的耦合降至最低。</u>

3. Go 惯例上推荐尽量定义**小接口**，一般而言接口方法集合中的方法个数不要超过三个，单一方法的接口更受 Go 社区青睐。

4. 小接口有诸多优点，比如，**抽象程度高**、**易于测试与实现**、**与组合的设计思想一脉相承**、**鼓励你编写组合的代码**，等等。

   