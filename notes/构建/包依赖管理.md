

# 1.GOPATH

1. Go 语言在首次开源时，就内置了一种名为 GOPATH 的构建模式。在这种构建模式下，Go 编译器可以<u>在本地 **GOPATH 环境变量配置的路径**下，搜寻 Go 程序依赖的第三方包</u>。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。

2. 那么，当遇到像上面例子一样，没有在本地找到程序的第三方依赖包的情况，我们该如何解决这个问题呢？

   我们可以通过 **go get** 命令将本地缺失的第三方依赖包下载到本地

   这里的 go get 命令，不仅能将 logrus 包下载**到 GOPATH 环境变量配置的目录**下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。

3. 不过，go get 下载的包**只是那个时刻各个依赖包的最新主线版本**，这样会给后续 Go 程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，得到不同的结果，也就是**不能保证可重现的构建**（Reproduceable Build）。

4. 也就是说，在 **GOPATH** 构建模式下，Go 编译器实质上==**并没有关注 Go 项目所依赖的第三方包的版本**==。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 **Vendor** 机制试图解决上面的问题。



# 2.Vender

1. Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是**在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来**，这个特定目录名就是 **vendor**。

2. Go 编译器会**优先感知和使用 vendor 目录下缓存的第三方包版本**，而**不是** GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。

3. 这里你还要注意一点，要想开启 vendor 机制，**你的 Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面**。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的。

4. 不过 vendor 机制虽然一定程度解决了 Go 程序可重现构建的问题，但对开发者来说，它的体验却不那么好。一方面，**Go 项目必须放在 GOPATH 环境变量配置的路径下**，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。

   另外，你还需要**手工管理 vendor 下面的 Go 依赖包**，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等，最让开发者头疼的就是这一点。

   为了解决这个问题，Go 核心团队与社区将 Go 构建的重点转移到如何解决包依赖管理上。Go 社区先后开发了诸如 gb、glide、dep 等工具，来帮助 Go 开发者对 vendor 下的第三方包进行自动依赖分析和管理，但这些工具也都有自身的问题。

5. 就在 Go 社区为包依赖管理焦虑并抱怨没有官方工具的时候，Go 核心团队基于社区实践的经验和教训，推出了 Go 官方的解决方案：**Go Module**。



# 3.GO Module

1. 一个 Go Module 是一个 **Go 包的集合**。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。
2. 在 Go Module 模式下，通常**一个代码仓库对应一个 Go Module**。一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 **Go Module 与 go.mod 是一一对应的。**
3. go.mod 文件所在的顶层目录也被称为 module 的**根目录**，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。



**创建一个module**

将基于当前项目创建一个 Go Module，通常有如下几个步骤：

1. 通过 **go mod init** 创建 go.mod 文件，将当前项目变为一个 Go Module；
2. 通过 **go mod tidy** 命令自动更新当前 module 的依赖信息；
3. 执行 **go build**，执行新 module 的构建。



1. 对于一个处于初始状态的 module 而言，**go mod tidy** 分析了当前 main module 的所有源文件，**找出**了当前 main module 的所有第三方依赖，**确定第三方依赖的版本，还下载**了当前 main module 的直接依赖包（比如 logrus），以及相关间接依赖包（直接依赖包的依赖，比如上面的 golang.org/x/sys 等）。

2. 由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]/pkg/mod，Go 1.15 及以后版本可以通过 **GOMODCACHE** 环境变量，自**定义本地 module 的缓存路径。**

3. 而且，执行完 go mod tidy 后，当前项目除了 go.mod 文件外，还多了一个新文件 **go.sum**，

   这同样是由 go mod 相关命令维护的一个文件，它存放了**特定版本 module 内容的哈希值**。

   这是 Go Module 的一个**安全措施**。当将来这里的某个 module 的特定版本被再次下载的时候，go 命令会使用 go.sum 文件中对应的哈希值，和新下载的内容的哈希值进行比对，只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的 module 内容，**不会被恶意或意外篡改**。

4. go build 命令会<u>读取 go.mod 中的依赖及版本信息</u>，并<u>在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接</u>。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。





# 4.深入 Go Module 构建模式

那么，在看到我们的 Go Module 机制会自动分析项目的依赖包，并选出最适合的版本后，不知道你会不会有这样的疑惑：**项目所依赖的包有很多版本，Go Module 是如何选出最适合的那个版本的呢？**要想回答这个问题，我们就需要深入到 Go Module 构建模式的工作原理中去。



Go 语言设计者在设计 Go Module 构建模式，来解决“**包依赖管理**”的问题时，进行了几项创新，这其中就包括**语义导入版本** (Semantic Import Versioning)，以及和其他主流语言不同的**最小版本选择** (Minimal Version Selection) 等机制。只要你深入理解了这些机制，你就能真正掌握 Go Module 构建模式。



## 4.1语义导入版本机制

1. Go Module 创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下面这样导入 logrus v2.0.0 版本依赖包：

   ```go
   import "github.com/sirupsen/logrus/v2"
   ```

   这就是 Go 的“语义导入版本”机制，也就是说**通过在包导入路径中引入主版本号的方式**，来**区别同一个包的不兼容版本**，这样一来我们甚至可以同时依赖一个包的两个不兼容版本：

   ```go
   import ( "github.com/sirupsen/logrus" 
           logv2 "github.com/sirupsen/logrus/v2"
   )
   ```

2. Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用**不带主版本号的包导入路径**，这样一定程度降低了 Go 开发人员使用这样版本号包时的心智负担。

3. Go 语义导入版本机制是 Go Module 机制的基础规则，同样它也是 Go Module **其他规则的基础**。



## 4.2最小版本选择机制

![img](https://static001.geekbang.org/resource/image/49/1b/49eb7aa0458d8ec6131d9e5661155f1b.jpeg?wh=1920x1080)

1. Go 设计者另辟蹊径，在诸多兼容性版本间，他们不光要考虑最新最大的稳定与安全，还要尊重各个 module 的述求：A 明明说只要求 C v1.1.0，B 明明说只要求 C v1.3.0。所以 Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“**最小版本”**。
2. 这个例子中，C v1.3.0 是**符合项目整体要求的版本集合中的版本最小的那个**，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。并且，Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。





# 5.构建模式切换

![img](https://static001.geekbang.org/resource/image/45/d3/45bdecc5fa873e06893d6658e447a8d3.jpeg?wh=1920x1080)



# 小结

1. 在这一讲中，我们初步了解了 Go 语言构建模式的演化历史。
2. Go 语言最初发布时内置的构建模式为 **GOPATH** 构建模式。在这种构建模式下，所有构建都离不开 **GOPATH** 环境变量。在这个模式下，Go 编译器并**没有关注依赖包的版本**，开发者也无法控制第三方依赖的版本，导致开发者**无法实现可重现的构建**。
3. 那么，为了**支持可重现构建**，Go 1.5 版本引入了 **vendor** 机制，**开发者可以在项目目录下缓存项目的所有依赖**，实现可重现构建。但 vendor 机制依旧不够完善，开发者还需要**手工管理** vendor 下的依赖包，这就给开发者带来了不小的心智负担。
4. 后来，Go 1.11 版本中，Go 核心团队推出了新一代构建模式：**Go Module** 以及一系列创新机制，包括**语义导入版本机制**、**最小版本选择机制**等。**语义导入版本机制**是 Go Moudle 其他机制的**基础**，它是<u>通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本</u>。而且，Go 命令使用最小版本选择机制进行包依赖版本选择，这和当前主流编程语言，以及 Go 社区之前的包依赖管理工具使用的算法都有点不同。
5. 此外，Go 命令还可以通过 `GO111MODULE` 环境变量进行 Go 构建模式的切换。但你要注意，从 Go 1.11 到 Go 1.16，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式以及具体表现行为也几经变化，这里你重点看一下前面总结的表格。
6. 现在，Go 核心团队已经考虑在后续版本中**彻底移除 GOPATH 构建模式**，Go Module 构建模式将成为 Go 语言**唯一**的标准构建模式。所以，学完这一课之后，我建议你从现在开始就彻底抛弃 GOPATH 构建模式，全面使用 Go Module 构建模式。