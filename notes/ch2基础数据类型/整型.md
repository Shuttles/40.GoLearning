1. Go语言同时提供了**有符号**和**无符号类型**的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。
2. 这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数**int和uint**；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。
3. Unicode字符**rune**类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样**byte也是uint8类型的等价类型**，byte类型一般用于强调数值是一个**原始的数据**而不是一个小的整数。
4. 最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。
5. 不管它们的具体大小，**int、uint和uintptr是不同类型的兄弟类型**。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。



# 运算符

1. 下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照**优先级递减**的顺序排列：

   ```go
   *      /      %      <<       >>     &       &^
   +      -      |      ^
   ==     !=     <      <=       >      >=
   &&
   ||
   ```

2. 二元运算符有五种优先级。在同一个优先级，使用==左优先结合==规则，但是使用括号可以明确优先顺序

3. 取模运算符%仅用于**整数间**的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的**符号总是一致**的，因此`-5%3`和`-5%-3`结果都是-2。

4. 除法运算符`/`的行为则依赖于**操作数是否全为整数**，比如`5.0/4.0`的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。

5. Go语言还提供了以下的bit位操作运算符，前面4个操作运算符**并不区分**是有符号还是无符号数：

   ```go
   &      位运算 AND
   |      位运算 OR
   ^      位运算 XOR
   &^     位清空（AND NOT）
   <<     左移
   >>     右移
   ```

   位操作运算符`^`作为二元运算符时是**按位异或**（XOR），当用作一元运算符时表示**按位取反**；也就是说，它返回一个每个bit位都取反的数。

   位操作运算符`&^`用于**按位置零**（AND NOT）：如果对应y中bit位为1的话，表达式`z = x &^ y`结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。

6. 在`x<<n`和`x>>n`移位运算中，决定了移位操作的bit数部分必须是**无符号数**；被操作的x可以是有符号数或无符号数。算术上，一个`x<<n`左移运算等价于乘以$2^n$，一个`x>>n`右移运算等价于除以$2^n$。

   左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。

7. 尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是**倾向于使用有符号的int类型**，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。事实上，内置的len函数返回一个有符号的int，我们可以像下面例子那样处理逆序循环。

   ```Go
   medals := []string{"gold", "silver", "bronze"}
   for i := len(medals) - 1; i >= 0; i-- {
       fmt.Println(medals[i]) // "bronze", "silver", "gold"
   }
   ```

8. 无符号数往往只有在**位运算或其它特殊的运算场景**才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。





# 类型转换

1. 一般来说，需要一个**显式的转换**将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是**相同的类型**。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关的问题，而且也使得程序容易理解。

   在很多场景，会遇到类似下面代码的常见的错误：

   ```Go
   var apples int32 = 1
   var oranges int16 = 2
   var compote int = apples + oranges // compile error
   ```

2. 这种类型不匹配的问题可以有几种不同的方法修复，最常见方法是将它们都**显式转型为一个常见类型：**

   ```Go
   var compote = int(apples) + int(oranges)
   ```



# 进制

1. 任何大小的整数字面值都可以用以**0开始的八进制格式**书写，例如0666；或用以**0x或0X开头的十六进制格式**书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。

2. 如今八进制数据通常用于POSIX操作系统上的**文件访问权限标志**，十六进制数字则更强调**数字值的bit位模式**。

3. 当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式，就像下面的例子：

   ```Go
   o := 0666
   fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
   x := int64(0xdeadbeef)
   fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
   // Output:
   // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
   ```

   请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的**`[1]`副词告诉Printf函数再次使用第一个操作数**。第二，%后的**`#`副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀**。



# 字符面值

1. 字符面值通过**一对单引号**直接包含对应字符。最简单的例子是ASCII中类似**'a'写法的字符面值**，但是我们也可以通过转义的数值来表示任意的Unicode码点对应的字符，马上将会看到这样的例子。

2. 字符使用`%c`参数打印，或者是用`%q`参数打印带单引号的字符：

   ```Go
   ascii := 'a'
   unicode := '国'
   newline := '\n'
   fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
   fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
   fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
   ```