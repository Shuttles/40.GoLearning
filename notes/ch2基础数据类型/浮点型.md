1. Go语言提供了两种精度的浮点数，**float32**和**float64**。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。

2. 这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在**math包**找到。

   常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；

   对应的math.MaxFloat64常量大约是1.8e308。

   它们分别能表示的最小值近似为1.4e-45和4.9e-324。

3. 一个**float32**类型的浮点数可以提供大约**6个十进制数的精度**，而**float64**则可以提供约**15个十进制数**的精度；

4. ==通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大==（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）

5. 用Printf函数的**%g参数打印浮点数**，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用`%e`（带指数）或`%f`的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。



# 特殊值

1. math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).

   ```Go
   var z float64
   fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
   ```

2. 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）：

   ```Go
   nan := math.NaN()
   fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
   ```

3. 如果一个函数返回的浮点数结果**可能失败**，最好的做法是**用单独的标志报告失败**，像这样：

   ```Go
   func compute() (value float64, ok bool) {
       // ...
       if failed {
           return 0, false
       }
       return result, true
   }
   ```

