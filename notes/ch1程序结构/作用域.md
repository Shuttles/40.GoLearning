1. 一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的**作用域**是指源代码中**可以有效使用这个名字的范围**。

2. 不要将**作用域**和**生命周期**混为一谈。声明语句的**作用域**对应的是**一个源代码的文本区域**；它是一个**编译时的属性**。一个变量的**生命周期**是指程序**运行时变量存在的有效时间段**，在此时间区域内它可以被程序的其他部分引用；是一个**运行时**的概念。

3. **句法块**是由**花括弧所包含的一系列语句**，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是**无法被外部块访问的**。这个块决定了内部声明的名字的作用域范围。

   我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为**全局词法块**；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。

4. 声明语句对应的**词法域决定了作用域范围的大小**。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。**任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。**

5. 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。



1. 当编译器遇到一个**名字**引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则**内部块的声明首先被找到**。**在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。**

2. **并不是所有的词法域都显式地对应到由花括弧包含的语句**；还有一些隐含的规则。

   上面的for语句创建了两个词法域：**花括弧包含的是显式的部分**，是for的循环体部分词法域，另外一个隐式的部分则是**循环的初始化部分**，比如用于迭代变量i的初始化。隐式的词法域部分的作用域还包含**条件测试部分**和循环后的**迭代部分**（`i++`），当然也包含循环体词法域。

3. 和for循环类似，if和switch语句也会在**条件部分创建隐式词法域**，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：

   ```Go
   if x := f(); x == 0 {
       fmt.Println(x)
   } else if y := g(x); x == y {
       fmt.Println(x, y)
   } else {
       fmt.Println(x, y)
   }
   fmt.Println(x, y) // compile error: x and y are not visible here
   ```

   第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。switch语句的每个分支也有类似的词法域规则：==条件部分为一个隐式词法域，然后是每个分支的词法域。==



1. 在**包级别**，声明的**顺序并不会影响作用域范围**，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。

   在这个程序中：

   ```Go
   if f, err := os.Open(fname); err != nil { // compile error: unused: f
       return err
   }
   f.ReadByte() // compile error: undefined f
   f.Close()    // compile error: undefined f
   ```

   变量f的**作用域只在if语句内**，因此后面的语句将无法引入它，这将导致编译错误。你可能会收到一个局部变量f没有声明的错误提示，具体错误信息依赖编译器的实现。

2. 通常需要**在if之前声明变量**，这样可以确保后面的语句依然可以访问变量。

3. 你可能会考虑通过将ReadByte和Close移动到if的else块来解决这个问题，但这不是Go语言推荐的做法，Go语言的习惯是**在if中处理错误然后直接返回**，这样可以确保正常执行的语句**不需要代码缩进**。



# 短变量声明的作用域

1. 要特别注意短变量声明语句的作用域范围，考虑下面的程序，它的目的是**获取当前的工作目录然后保存到一个包级的变量中**。这本来可以通过直接调用os.Getwd完成，但是将这个从主逻辑中分离出来可能会更好，特别是在**需要处理错误**的时候。函数log.Fatalf用于打印日志信息，然后调用os.Exit(1)终止程序。

   ```Go
   var cwd string
   
   func init() {
       cwd, err := os.Getwd() // compile error: unused: cwd
       if err != nil {
           log.Fatalf("os.Getwd failed: %v", err)
       }
   }
   ```

   虽然cwd在外部已经声明过，==但是`:=`语句还是将cwd和err重新声明为新的局部变量==。因为==内部声明的cwd将屏蔽外部的声明==，因此上面的代码并不会正确更新包级声明的cwd变量。

2. 有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用`:=`的简短声明方式：

   ```Go
   var cwd string
   
   func init() {
       var err error
       cwd, err = os.Getwd()
       if err != nil {
           log.Fatalf("os.Getwd failed: %v", err)
       }
   }
   ```