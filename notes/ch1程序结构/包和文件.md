1. Go语言中的包和其他语言的**库或模块**的概念类似，目的都是为了**支持模块化、封装、单独编译和代码重用**。**一个包的源代码保存在一个或多个以.go为文件**后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。
2. 每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。
3. 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：**如果一个名字是大写字母开头的，那么该名字是导出的**（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。



# 1.导入包

1. 在Go语言程序中，**每个包都有一个全局唯一的导入路径**。导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。

2. 除了包的导入路径，**每个包还有一个包名**，包名一般是短小的名字（并不要求包名是唯一的），**包名在包的声明处指定**。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。

3. 导入语句将导入的包绑定到**一个短小的名字**，然后通过该短小的名字就可以引用包中导出的全部内容。上面的导入声明将允许我们以tempconv.CToF的形式来访问gopl.io/ch2/tempconv包中的内容。在默认情况下，**导入的包绑定到tempconv名字**（译注：指包声明语句指定的名字），但是我们也可以绑定到另一个名称，以避免名字冲突（§10.4）。

4. **如果导入了一个包，但是又没有使用该包**将被当作一个编译**错误**处理。这种强制规则可以有效减少不必要的依赖，虽然在调试期间可能会让人讨厌，因为删除一个类似log.Print("got here!")的打印语句可能导致需要同时删除log包导入声明，否则，编译器将会发出一个错误。在这种情况下，我们需要将不必要的导入删除或注释掉。

   不过有更好的解决方案，我们可以使用golang.org/x/tools/cmd/**goimports导入工具**，它可以**根据需要自动添加或删除导入的包**；许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以用来格式化Go源文件。



# 2.包的初始化

1. 包的初始化首先是**解决包级变量的依赖顺序**，然后按照包级变量**声明出现的顺**序依次初始化：

   ```Go
   var a = b + c // a 第三个初始化, 为 3
   var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
   var c = 1     // c 第一个初始化, 为 1
   
   func f() int { return c + 1 }
   ```

2. 如果包中含有多个.go源文件，它们将按照**发给编译器的顺序**进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

3. 对于在**包级别声明的变量**，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。**每个文件都可以包含多个init初始化函数**

   ```Go
   func init() { /* ... */ }
   ```

   这样的init初始化函数**除了不能被调用或引用外**，其他行为和普通函数类似。在每个文件中的init初始化函数，**在程序开始执行时按照它们声明的顺序被自动调用**。

4. 每个包在**解决依赖的前提**下，以**导入声明的顺序初始化**，每个包只会被初始化**一次**。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是**自下而上**进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。

   