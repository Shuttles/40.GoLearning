# 1.命名

1. 一个名字必须以一个**字母**（Unicode字母）或**下划线**开头，后面可以跟任意数量的**字母**、**数字**或**下划线**。大写字母和小写字母是不同的。
2. 如果一个名字是在函数**内部**定义，那么它就**只在函数内部有效**。如果是在函数**外部**定义，那么将在**当前包的所有文件中**都可以访问。
3. 名字的**开头字母的大小写**决定了**名字在包外的可见性**。如果一个名字是**大写**字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是**导出**的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。**包本身**的名字一般总是用**小写**字母。
4. 通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。
5. 在习惯上，Go语言程序员推荐使用 **驼峰式** 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。



# 2.声明

1. 声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应**变量**、**常量**、**类型**和**函数实体对象**的声明。

2. 一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的**声明语句开始**，说明该源文件是属于哪个包。包声明语句之后是**import语句导入依赖的其它包**，然后是**包一级的类型、变量、常量、函数的声明语句**，**包一级的**各种类型的声明语句的**顺序无关紧要**（译注：函数内部的名字则必须先声明之后才能使用）。

3. 在**包一级声明语句声明的名字可在整个包对应的每个源文件中访问**，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。

4. 一个**函数的声明**由一个**函数名字**、**参数列表**（由函数的调用者提供参数变量的具体值）、一个**可选的返回值列表**和包含函数定义的**函数体**组成。

   如果函数没有返回值，那么返回值列表是省略的。

   执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。



# 3.变量

1. var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

   ```Go
   var 变量名字 类型 = 表达式
   ```

   **其中“*类型*”或“*= 表达式*”两个部分可以省略其中的一个。**如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用**零值**初始化该变量。 

   数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是**nil**。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

   零值初始化机制可以确保每个声明的变量**总是有一个良好定义的值**，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。

2. **也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。**如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：

   ```Go
   var i, j, k int                 // int, int, int
   var b, f, s = true, 2.3, "four" // bool, float64, string
   ```

   初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。

   一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：

   ```Go
   var f, err = os.Open(name) // os.Open returns a file and an error
   ```



## 3.1短变量声明

1. 在==**函数内部**==，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。下面是lissajous函数中的三个简短变量声明语句（§1.4）：

   ```Go
   freq := rand.Float64() * 3.0
   t := 0.0
   ```

   因为简洁和灵活的特点，==简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方==。

   ```Go
   i := 100                  // an int
   var boiling float64 = 100 // a float64
   var names []string
   var err error
   var p Point
   ```

2. 和var形式声明语句一样，简短变量声明语句也可以用来**声明和初始化一组变量**：

   ```Go
   i, j := 0, 1
   ```

   但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。

3. 请记住“:=”是一个变量**声明**语句，而“=”是一个变量**赋值**操作。**也不要混淆多个变量的声明和元组的多重赋值**（§2.4.1），后者是将右边各个表达式的值赋值给左边对应位置的各个变量：

   ```Go
   i, j = j, i // 交换 i 和 j 的值
   ```

4. 简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了（§2.7），那么简短变量声明语句对这些已经声明过的变量就**只有赋值行为了。**

   简短变量声明语句中必须**至少要声明一个新的变量**



## 3.2指针

1. 一个指针的值是另一个变量的**地址**。

   通过指针，我们可以直接读或更新对应变量的值，而**不需要知道该变量的名字**（如果变量有名字的话）。

2. 如果用“var x int”声明语句声明一个x变量，那么**&x**表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是`*int`，指针被称之为“指向int类型的指针”。

   如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时**`*p`表达式对应p指针指向的变量的值**。一般`*p`表达式读取指针指向的变量的值，这里为int类型的值，同时因为`*p`对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。

   ```Go
   x := 1
   p := &x         // p, of type *int, points to x
   fmt.Println(*p) // "1"
   *p = 2          // equivalent to x = 2
   fmt.Println(x)  // "2"
   ```

3. 任何类型的指针的**零值都是nil**。如果p指向某个有效变量，那么`p != nil`测试为真。指针之间也是可以进行**相等测试**的，只有当它们指向同一个变量或全部是nil时才相等。

4. 在Go语言中，**返回函数中局部变量的地址也是安全的**。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

   ```Go
   var p = f()
   
   func f() *int {
       v := 1
       return &v
   }
   ```

   每次调用f函数都将返回不同的结果：

   ```Go
   fmt.Println(f() == f()) // "false"
   ```

5. 每次我们对一个变量取地址，或者复制指针，我们都是**为原变量创建了新的别名**。例如，`*p`就是变量v的别名。

   指针特别有价值的地方在于==我们可以不用名字而访问一个变量==，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：**这是Go语言的垃圾回收器所做的工作**）。不仅仅是指针会创建别名，**很多其他引用类型也会创建别名**，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。



## 3.3new函数

1. 另一个创建变量的方法是调用内建的**new函数**。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，**返回的指针类型为`*T`**。

   ```Go
   p := new(int)   // p, *int 类型, 指向匿名的 int 变量
   fmt.Println(*p) // "0"
   *p = 2          // 设置 int 匿名变量的值为 2
   fmt.Println(*p) // "2"
   ```

2. 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，**new函数类似是一种语法糖**，而不是一个新的基础概念。

3. 每次调用new函数都是**返回一个新的变量的地址**，因此下面两个地址是不同的：

   ```Go
   p := new(int)
   q := new(int)
   fmt.Println(p == q) // "false"
   ```

   当然也可能有特殊情况：如果两个类型都是**空的**，也就是说类型的**大小是0**，例如`struct{}`和`[0]int`，有可能有相同的地址（依赖具体的语言实现）（译注：==请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为==，具体请查看`runtime.SetFinalizer`函数相关文档）。

   new函数使用通常相对比较**少**，因为对于**结构体**来说，直接用**字面量语法**创建新变量的方法会更灵活（§4.4.1）。

4. 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：

   ```Go
   func delta(old, new int) int { return new - old }
   ```

   由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。（==没看懂！！！！==）



## 3.4变量生命周期

1. 对于在**包一级**声明的变量来说，它们的生命周期**和整个程序的运行周期是一致的**。

2. 而相比之下，**局部变量**的生命周期则是**动态**的：每次从创建一个新变量的声明语句开始，**直到该变量不再被引用为止，然后变量的存储空间可能被回收**。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

3. 那么Go语言的**自动垃圾收集器**是如何知道一个变量是何时可以被回收的呢？

   这里我们可以避开完整的技术细节，基本的实现思路是，==从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，**是否可以找到该变量**。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。==

   因为一个变量的有效周期**只取决于是否可达**，因此==一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在==。

4. 编译器会**自动选择**在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

   ```Go
   var global *int
   
   func f() {
       var x int
       x = 1
       global = &x
   }
   
   func g() {
       y := new(int)
       *y = 1
   }
   ```

   f函数里的x变量必须在堆上分配，因为它**在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的**；用Go语言的术语说，这个x局部变量从函数f中逃逸了。

   相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。

   其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

5. Go语言的自动垃圾收集器对编写正确的代码是一个**巨大的帮助**，但也**并不是说你完全不用考虑内存了**。

   你虽然不需要显式地分配和释放内存，但是要编写高效的程序你**依然需要了解变量的生命周期**。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。





# 4.赋值

1. 自增和自减是语句，而不是表达式，因此`x = i++`之类的表达式是**错误**的



## 4.1元组赋值

1. 元组赋值是另一种形式的赋值语句，它允许**同时更新多个变量的值**。

   在赋值之前，赋值语句**右边**的所有表达式将会**先进行求值**，然后再**统一更新左边**对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：

   ```Go
   x, y = y, x
   
   a[i], a[j] = a[j], a[i]
   ```

2. 或者是计算两个整数值的的最大公约数（GCD）（译注：GCD不是那个敏感字，而是greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法）：

   ```Go
   func gcd(x, y int) int {
       for y != 0 {
           x, y = y, x%y
       }
       return x
   }
   ```

3. 或者是计算斐波纳契数列（Fibonacci）的第N个数：

   ```Go
   func fib(n int) int {
       x, y := 0, 1
       for i := 0; i < n; i++ {
           x, y = y, x+y
       }
       return x
   }
   ```

4. 元组赋值也可以使一系列琐碎赋值更加**紧凑**（译注: 特别是在for循环的初始化部分），

   ```Go
   i, j, k = 2, 3, 5
   ```

   但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。

5. 有些表达式会产生多个值，比如调用一个**有多个返回值的函数**。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。

   ```Go
   f, err = os.Open("foo.txt") // function call returns two values
   ```

6. 通常，这类函数会**用额外的返回值来表达某种错误类型**，例如os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为**ok**。在稍后我们将看到的三个操作都是类似的用法。如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的**布尔结果**表示操作是否成功：

   ```Go
   v, ok = m[key]             // map lookup
   v, ok = x.(T)              // type assertion
   v, ok = <-ch               // channel receive
   ```

7. 和变量声明一样，我们可以用下划线空白标识符`_`来**丢弃不需要的值。**

   ```Go
   _, err = io.Copy(dst, src) // 丢弃字节数
   _, ok = x.(T)              // 只检测类型，忽略具体值
   ```



## 4.2可赋值性

1. 可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。
2. 对于目前我们已经讨论过的类型，它的规则是简单的：**类型必须完全匹配**，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。



# 5.类型

1. 一个类型声明语句创建了一个**新的类型名称**，**和现有类型具有相同的底层结构**。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

   ```Go
   type 类型名字 底层类型
   ```

   类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。

2. ```go
   // Package tempconv performs Celsius and Fahrenheit temperatur computations.
   package tempconv
   
   import "fmt"
   
   type Celsius float64 //摄氏温度
   type Fahrenheit float64 //华氏温度
   
   const (
       AbsoluteZeroC Celsius = -273.15 // 绝对零度
       FreezingC     Celsius = 0       // 结冰点温度
       BoilingC      Celsius = 100     // 沸水温度
   )
   
   func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
   
   func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
   ```

3. 我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应**不同的温度单位**。它们虽然有着相同的底层类型float64，但是它们是**不同**的数据类型，因此它们**不可以**被相互比较或混在一个表达式运算。

4. ==刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误==；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并**不是函数调用**。==类型转换不会改变值本身，但是会使它们的语义发生变化==。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。

5. **对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型**（译注：如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`）。**只有当两个类型的底层基础类型相同时**，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。

6. 底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。**这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的**，正如我们所期望的那样。

   ```Go
   fmt.Printf("%g\n", BoilingC-FreezingC) // "100" °C
   boilingF := CToF(BoilingC)
   fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
   fmt.Printf("%g\n", boilingF-FreezingC)       // compile error: type mismatch
   ```

7. 比较运算符`==`和`<`也可以用来比较一个**命名类型的变量**和另一个**有相同类型的变量**，或**有着相同底层类型的未命名类型的值**之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：

   ```Go
   var c Celsius
   var f Fahrenheit
   fmt.Println(c == 0)          // "true"
   fmt.Println(f >= 0)          // "true"
   fmt.Println(c == f)          // compile error: type mismatch
   fmt.Println(c == Celsius(f)) // "true"!
   ```

8. 命名类型还可以为该类型的值定义**新的行为**。这些行为表示为一组关联到该类型的函数集合，我们称为类型的**方法集**。我们将在第六章中讨论方法的细节，这里只说些简单用法。

   下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串：

   ```Go
   func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
   ```

   许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印，我们将在7.1节讲述。

   ```Go
   c := FToC(212.0)
   fmt.Println(c.String()) // "100°C"
   fmt.Printf("%v\n", c)   // "100°C"; no need to call String explicitly
   fmt.Printf("%s\n", c)   // "100°C"
   fmt.Println(c)          // "100°C"
   fmt.Printf("%g\n", c)   // "100"; does not call String
   fmt.Println(float64(c)) // "100"; does not call String
   ```